/*
*
*/

#include <sstream>
#include <algorithm>
#include <fstream>

#include <QStringList>
#include <QByteArray>

#include <DateConverter.h>
#include <ObsSequence.h>
#include <SitesMask.h>
#include <Site.h>
#include <Sites.h>

#include "PPSurphOutput.h"
#include "PPVersion.h"
#include "PitProSettings.h"

using std::string;
using std::stringstream;
using std::endl;
using std::min;
using std::ifstream;

using namespace cbr;

void PPSurphOutput::close() 
{
    tmpOut.close();
    PPFileOutput::close();
}

void PPSurphOutput::closeAndDelete() 
{
    tmpOut.closeAndDelete();
    PPFileOutput::closeAndDelete();
}

void PPSurphOutput::setPrefix(const std::string& prefix) 
{
    PPFileOutput::setPrefix( prefix );
    tmpOut.setPrefix( prefix );
}

string PPTmpOutput::getFileName (const string& prefix) const
{
    PitProSettings& settings = PitProSettings::getInstance();
    string suffix = settings.getValue (PitProSettings::SurphSuffix);
    return settings.getOutFilePath (prefix + "_tmp.txt");
}

string PPSurphOutput::getFileName (const string& prefix) const
{
    PitProSettings& settings = PitProSettings::getInstance();
    string suffix = settings.getValue (PitProSettings::SurphSuffix);
    return settings.getOutFilePath (prefix + "." + suffix);
}

void PPSurphOutput::writeSiteLegend()
{
    if (ofs.is_open())
    {
        ofs << "# Key to outcome codes:" << endl;
        ofs << "#" << endl;
        ofs << "#   Dam sites:" << endl;
        ofs << "#     R: Returned to River (usually River Exit or \"Adult Fish Return\")" << endl;
        ofs << "#     B: Full-Flow Bypass" << endl;
        ofs << "#     T: Transported" << endl;
        ofs << "#     S: Sampled (detected in Sample Room)" << endl;
        ofs << "#     H: Held (usually means detained by Separation-by-Code)" << endl;
        ofs << "#     U: Unknown (disposition unknown)" << endl;
        ofs << "#     P: Detected in Spillway" << endl;
        ofs << "#" << endl;
        ofs << "#   Aggregated Data Sources After Smolts Pass Bonneville:" << endl;
        ofs << "#    Live Detection:" << endl;
        ofs << "#     R: Estuary PIT Trawl" << endl;
        ofs << "#     D: Pile Dike" << endl;
        ofs << "#     G: PIT Barge downstream of Bonneville Dam" << endl;
        ofs << "#     W: Adult Fish Ladder at Bonneville Dam" << endl;
        ofs << "#     A: Detected as a Returning Adult" << endl;
        ofs << "#    Dead Recovery:" << endl;
        ofs << "#     V: Various Avian Recovery (mostly island nesting colonies)" << endl;
        ofs << "#     M: Recovery from avian deposit on Astoria-Megler Bridge" << endl;
        ofs << "#     X: Recovery from avian deposit on transmission towers near Troutdale, OR" << endl;
        ofs << "#" << endl << endl;
    }
}

void PPSurphOutput::writeHeader( const std::string& outPrefix, 
        const SitesMask& mask,
        const RunConfigVector& runConfigVector,
        const IntVector& groupSizes,
        bool writeICovs,
        std::string histFormat)
{
    if (!ofs.is_open())
        return;

    PitProSettings& settings = PitProSettings::getInstance();
    string outputFormat = settings.getValue( PitProSettings::OutputFormat );

    /* print header */
    DateConverter currentTime;
    ofs << "#" << endl;
    ofs << "# Format: " << outputFormat << endl;
    ofs << "#" << endl;
    ofs << "# Generated by PitPro on " << currentTime << endl;
    ofs << "#     PitPro version:    " << PPVersion::versionString() << endl;
    ofs << "#     Sites config date: " << Sites::getInstance()->getConfigDate() << endl;
    ofs << "#" << endl;
    ofs << settings.writeLegend();
    StringVector groupNames;
    for (RunConfigVector::const_iterator it = runConfigVector.begin(); it != runConfigVector.end(); ++it )
    {
        const RunConfigItem& runItem = *it;
        groupNames.push_back(runItem.name);
        ofs << "# Run config:" << endl;
        ofs << "#   name:  " << runItem.name << endl;
        ofs << "#   obs:   " << runItem.obs << endl;
        ofs << "#   tag:   " << runItem.tag << endl;
        ofs << "#   recap: " << runItem.recap << endl;
        ofs << "#   mort:  " << runItem.mort << endl;
        ofs << "#" << endl;
    }
    ofs << "#" << endl;

    /* print capture history fields as comments */
    ofs << getSurphFileLegend (mask, writeICovs, outputFormat);
    if (histFormat == "All") {
        writeSiteLegend();
    }


    if ( !outputFormat.compare( "SURPH1" ) ) {
        writeSurph1Header(outPrefix, mask, groupNames, groupSizes, writeICovs);
    }
    else if ( !outputFormat.compare( "ROSTER" ) ) {
        writeRosterHeader();
    }
    else {
        writeSurph2Header(outPrefix, mask, groupNames, groupSizes, writeICovs);
    }
}

void PPSurphOutput::writeRosterHeader() 
{
}

void PPSurphOutput::writeSurph1Header( const std::string& outPrefix, 
          const SitesMask& mask,
          const StringVector& groupNames,
          const IntVector& groupSizes,
          bool writeICovs)
{
    ofs << "Data" << endl;
    ofs << outPrefix << endl << endl;
    SitesMaskVector maskVector = mask.getVector();
    ofs << "npop " << groupNames.size() << endl;
    ofs << "nper " << mask.numPeriods() << endl << endl;

    if (writeICovs && numICovs > 0) {
        for (int i = 1; i <= numICovs; ++i)
            ofs << "icov icov" << i << endl;
        ofs << endl;
    }

    /* print population names */
    ofs << "population_names" << endl;
    for (StringVector::const_iterator it = groupNames.begin(); it != groupNames.end(); ++it)
    {
        string name = *it;
        name.resize(min(name.size(), static_cast<size_t>(15)));

        QString outname(name.c_str());
        outname.replace(QString(" "), QString("_"));

        ofs << outname.toLatin1().data() << endl;
    }
    ofs << endl;

    /* print number of tagged fish per group */
    ofs << "ntag" << endl;
    for (IntVector::const_iterator it = groupSizes.begin(); it != groupSizes.end(); ++it)
    {
        ofs << *it;
        for (unsigned int i = 0; i < mask.numPeriods() - 1; ++i)
            ofs << " 0";
        ofs << endl;
    }
    ofs << endl << endl;

    ofs << "full_hist" << endl << endl;
    ofs << "idlen 14" << endl << endl;
    ofs << "data" << endl;
}

void PPSurphOutput::writeSurph2Header( const std::string& outPrefix, 
        const SitesMask& mask,
        const StringVector& groupNames,
        const IntVector& groupSizes,
        bool writeICovs)
{

    /* standard header info */
    SitesMaskVector maskVector = mask.getVector();
    ofs << "Surph2" << endl;
    ofs << outPrefix << endl << endl;
    ofs << "npop " << groupNames.size() << endl << endl;
    ofs << "nper " << mask.numPeriods() << endl << endl;

    if (writeICovs && numICovs > 0) {
        for (int i = 1; i <= numICovs; ++i)
            ofs << "individual_covariate icov" << i << endl;
        ofs << endl;
    }

    /* print population names */
    ofs << "population_names" << endl;
    for (StringVector::const_iterator it = groupNames.begin(); it != groupNames.end(); ++it)
    {
        QString outname((*it).c_str());
        outname.replace(QString(" "), QString("_"));

        ofs << outname.toLatin1().data() << endl;
    }
    ofs << endl;

    /* print number of tagged fish per group */
    ofs << "ntag";
    for (IntVector::const_iterator it = groupSizes.begin(); it != groupSizes.end(); ++it)
    {
        ofs << " " << *it;
    }
    ofs << endl << endl;

    /* the rest */
    ofs << "full_hist" << endl << endl;
    ofs << "tagID present" << endl << endl;
    ofs << "captureHistories" << endl;
}

void PPSurphOutput::write (const std::string& outPrefix, 
       const SitesMask& mask,
       const RunConfigVector& runConfigVector,
       const IntVector& groupSizes,
       bool writeICovs,
       const std::string histFormat)
{
    if (!ofs.is_open())
            return;

    QString outp(outPrefix.c_str());
    outp.replace(QString(" "), QString("_"));
    writeHeader(outp.toStdString(), mask, runConfigVector, groupSizes, writeICovs, histFormat);
    tmpOut.close();
    string tmpFile = tmpOut.getFileName(prefix);
    ifstream ifs( tmpFile.c_str() );
    if (ifs.is_open())
    {
        string line;
        while (getline(ifs, line))
        {
            ofs << line << endl;
        }
    }
    ifs.close();
    tmpOut.closeAndDelete();

    writeFooter();
}

void PPSurphOutput::writeHist (ObsSequence& seq, const SitesMask& mask, bool checkForErrors)
{
    PitProSettings& settings = PitProSettings::getInstance();
    string outputFormat = settings.getValue( PitProSettings::OutputFormat );

    if (!checkForErrors || seq.getErrors().isOk())
    {
        stringstream ss;
        ss << seq.getPitCode();
        if ( outputFormat.compare( "ROSTER" ) != 0 )
            ss << " 1";
        ss << seq.hist (mask) << endl;
        tmpOut.write(ss.str());
    }
}

void PPSurphOutput::writeFooter() 
{
    if (!ofs.is_open())
            return;

    PitProSettings& settings = PitProSettings::getInstance();
    string outputFormat = settings.getValue( PitProSettings::OutputFormat );
    if ( !outputFormat.compare( "SURPH1" ) )
        ofs << "enddata" << endl;
}


bool
PPSurphOutput::active() const
{
    PitProSettings& settings = PitProSettings::getInstance();
    return settings.isChecked( PitProSettings::SurphFileSwitch );
}

string PPSurphOutput::getSurphFileLegend (const SitesMask& mask, bool lengthCovar, const string& format) const
{
stringstream ss;

unsigned int col = 0;
    unsigned int field = 0;
    int numJuvSites = mask.getNumJuvenileSites();
    unsigned int numMainSites = mask.getNumMainSites();
    SitesMaskVector maskVector = mask.getVector();
    bool isSiteRel = mask.isSiteRel();

    ss << "#" << endl;
    ss << "# Fields key" << endl;
    ss << "#" << endl;
    ss << "#  " << ++col << ": Pit Code" << endl;
    if (format.compare("ROSTER") != 0)
            ss << "#  " << ++col << ": Release Site" << endl;
    SitesMaskVector::const_iterator it = maskVector.begin();
    if (isSiteRel && it != maskVector.end())
            ++it;
    for (; it != maskVector.end(); ++it) {
        if (field < numMainSites)
            ss << "#  " << ++col << ": " << (*it)->getLongName()<< getStageKey (numJuvSites) << endl;
        else if (field == numMainSites)  {
            ss << "#  " << ++col << ": Combined" << endl;
            ss << "#       " << (*it)->getLongName() << getStageKey (numJuvSites) << endl;
        }
        else
            ss << "#       " << (*it)->getLongName() << getStageKey (numJuvSites) << endl;

        ++field;
    }
    if (lengthCovar)
        ss << "#  " << ++col << ": Length" << endl;
    ss << "#" << endl << endl;

    return ss.str();
}

string PPSurphOutput::getStageKey(int& numJuvSites) const
{
    stringstream ss;
    if ( numJuvSites == 0 )
        ss << " (A)";
    else if ( numJuvSites > 0 )
    {
        --numJuvSites;
        ss << " (J)";
    }

    return ss.str();
}
